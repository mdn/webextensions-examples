{"version":3,"sources":["idb-file-storage.js"],"names":["waitForDOMRequest","getFileStorage","req","onsuccess","Promise","resolve","reject","result","onerror","error","IDBPromisedFileHandle","constructor","file","lockedFile","writeQueue","closed","undefined","aborted","ensureLocked","invalidMode","Error","mode","active","reopenFileHandle","close","flush","abort","getMetadata","readAsText","size","location","readAsArrayBuffer","truncate","append","data","write","queuedWrite","nextWriteRequest","lastLocation","then","waitForQueuedWrites","IDBPromisedMutableFile","filesStorage","idb","fileName","fileType","mutableFile","fileHandle","open","getFile","persistAsFileSnapshot","snapshotName","initializedDB","runFileRequestGenerator","objectStore","getObjectStoreTransaction","put","bind","get","persist","generatorFunction","name","fileRequestsIter","processFileRequestIter","prevRequestResult","nextFileRequest","next","done","value","window","DOMRequest","IDBRequest","throw","request","IDBFileStorage","persistent","indexedDBName","objectStorageName","initializedPromise","version","IDBMutableFile","storage","dbReq","indexedDB","onupgradeneeded","db","objectStoreNames","contains","createObjectStore","transaction","createMutableFile","File","Blob","remove","delete","list","options","allKeys","getAllKeys","filteredKeys","filter","key","match","startsWith","endsWith","includes","filterFn","count","length","type","clear"],"mappings":"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","file":"idb-file-storage.js","sourcesContent":["\"use strict\";\n\n/**\n * @typedef {Object} IDBPromisedFileHandle.Metadata\n * @property {number} size\n *   The size of the file in bytes.\n * @property {Date} last Modified\n *   The time and date of the last change to the file.\n */\n\n/**\n * @typedef {Object} IDBFileStorage.ListFilteringOptions\n * @property {string} startsWith\n *   A string to be checked with `fileNameString.startsWith(...)`.\n * @property {string} endsWith\n *   A string to be checked with  `fileNameString.endsWith(...)`.\n * @property {string} includes\n *   A string to be checked with `fileNameString.includes(...)`.\n * @property {function} filterFn\n *   A function to be used to check the file name (`filterFn(fileNameString)`).\n */\n\n/**\n * Wraps a DOMRequest into a promise, optionally transforming the result using the onsuccess\n * callback.\n *\n * @param {IDBRequest|DOMRequest} req\n *   The DOMRequest instance to wrap in a Promise.\n * @param {function}  [onsuccess]\n *   An optional onsuccess callback which can transform the result before resolving it.\n *\n * @returns {Promise}\n *   The promise which wraps the request result, rejected if the request.onerror has been\n *   called.\n */\nexport function waitForDOMRequest(req, onsuccess) {\n  return new Promise((resolve, reject) => {\n    req.onsuccess = onsuccess ?\n      (() => resolve(onsuccess(req.result))) : (() => resolve(req.result));\n    req.onerror = () => reject(req.error);\n  });\n}\n\n/**\n * Wraps an IDBMutableFile's FileHandle with a nicer Promise-based API.\n *\n * Instances of this class are created from the\n * {@link IDBPromisedMutableFile.open} method.\n */\nexport class IDBPromisedFileHandle {\n  /**\n   * @private private helper method used internally.\n   */\n  constructor({file, lockedFile}) {\n    // All the following properties are private and it should not be needed\n    // while using the API.\n\n    /** @private */\n    this.file = file;\n    /** @private */\n    this.lockedFile = lockedFile;\n    /** @private */\n    this.writeQueue = Promise.resolve();\n    /** @private */\n    this.closed = undefined;\n    /** @private */\n    this.aborted = undefined;\n  }\n\n  /**\n   * @private private helper method used internally.\n   */\n  ensureLocked({invalidMode} = {}) {\n    if (this.closed) {\n      throw new Error(\"FileHandle has been closed\");\n    }\n\n    if (this.aborted) {\n      throw new Error(\"FileHandle has been aborted\");\n    }\n\n    if (!this.lockedFile) {\n      throw new Error(\"Invalid FileHandled\");\n    }\n\n    if (invalidMode && this.lockedFile.mode === invalidMode) {\n      throw new Error(`FileHandle should not be opened as '${this.lockedFile.mode}'`);\n    }\n    if (!this.lockedFile.active) {\n      // Automatically relock the file with the last open mode\n      this.file.reopenFileHandle(this);\n    }\n  }\n\n  // Promise-based MutableFile API\n\n  /**\n   * Provide access to the mode that has been used to open the {@link IDBPromisedMutableFile}.\n   *\n   * @type {\"readonly\"|\"readwrite\"|\"writeonly\"}\n   */\n  get mode() {\n    return this.lockedFile.mode;\n  }\n\n  /**\n   * A boolean property that is true if the lock is still active.\n   *\n   * @type {boolean}\n   */\n  get active() {\n    return this.lockedFile ? this.lockedFile.active : false;\n  }\n\n  /**\n   * Close the locked file (and wait for any written data to be flushed if needed).\n   *\n   * @returns {Promise}\n   *   A promise which is resolved when the close request has been completed\n   */\n  async close() {\n    if (!this.lockedFile) {\n      throw new Error(\"FileHandle is not open\");\n    }\n\n    // Wait the queued write to complete.\n    await this.writeQueue;\n\n    // Wait for flush request to complete if needed.\n    if (this.lockedFile.active && this.lockedFile.mode !== \"readonly\") {\n      await waitForDOMRequest(this.lockedFile.flush());\n    }\n\n    this.closed = true;\n    this.lockedFile = null;\n    this.writeQueue = Promise.resolve();\n  }\n\n  /**\n   * Abort any pending data request and set the instance as aborted.\n   *\n   * @returns {Promise}\n   *   A promise which is resolved when the abort request has been completed\n   */\n  async abort() {\n    if (this.lockedFile.active) {\n      // NOTE: in the docs abort is reported to return a DOMRequest, but it doesn't seem\n      // to be the case. (https://developer.mozilla.org/en-US/docs/Web/API/LockedFile/abort)\n      this.lockedFile.abort();\n    }\n\n    this.aborted = true;\n    this.lockedFile = null;\n    this.writeQueue = Promise.resolve();\n  }\n\n  /**\n   * Get the file metadata (take a look to {@link IDBPromisedFileHandle.Metadata} for more info).\n   *\n   * @returns {Promise<{size: number, lastModified: Date}>}\n   *   A promise which is resolved when the request has been completed\n   */\n  async getMetadata() {\n    this.ensureLocked();\n    return waitForDOMRequest(this.lockedFile.getMetadata());\n  }\n\n  /**\n   * Read a given amount of data from the file as Text (optionally starting from the specified\n   * location).\n   *\n   * @param {number} size\n   *   The amount of data to read.\n   * @param {number} [location]\n   *   The location where the request should start to read the data.\n   *\n   * @returns {Promise<string>}\n   *   A promise which resolves to the data read, when the request has been completed.\n   */\n  async readAsText(size, location) {\n    this.ensureLocked({invalidMode: \"writeonly\"});\n    if (typeof location === \"number\") {\n      this.lockedFile.location = location;\n    }\n    return waitForDOMRequest(this.lockedFile.readAsText(size));\n  }\n\n  /**\n   * Read a given amount of data from the file as an ArrayBufer (optionally starting from the specified\n   * location).\n   *\n   * @param {number} size\n   *   The amount of data to read.\n   * @param {number} [location]\n   *   The location where the request should start to read the data.\n   *\n   * @returns {Promise<ArrayBuffer>}\n   *   A promise which resolves to the data read, when the request has been completed.\n   */\n  async readAsArrayBuffer(size, location) {\n    this.ensureLocked({invalidMode: \"writeonly\"});\n    if (typeof location === \"number\") {\n      this.lockedFile.location = location;\n    }\n    return waitForDOMRequest(this.lockedFile.readAsArrayBuffer(size));\n  }\n\n  /**\n   * Truncate the file (optionally at a specified location).\n   *\n   * @param {number} [location=0]\n   *   The location where the file should be truncated.\n   *\n   * @returns {Promise<ArrayBuffer>}\n   *   A promise which is resolved once the request has been completed.\n   */\n  async truncate(location = 0) {\n    this.ensureLocked({invalidMode: \"readonly\"});\n    return waitForDOMRequest(this.lockedFile.truncate(location));\n  }\n\n  /**\n   * Append the passed data to the end of the file.\n   *\n   * @param {string|ArrayBuffer} data\n   *   The data to append to the end of the file.\n   *\n   * @returns {Promise}\n   *   A promise which is resolved once the request has been completed.\n   */\n  async append(data) {\n    this.ensureLocked({invalidMode: \"readonly\"});\n    return waitForDOMRequest(this.lockedFile.append(data));\n  }\n\n  /**\n   * Write data into the file (optionally starting from a defined location in the file).\n   *\n   * @param {string|ArrayBuffer} data\n   *   The data to write into the file.\n   * @param {number} location\n   *   The location where the data should be written.\n   *\n   * @returns {Promise<number>}\n   *   A promise which is resolved to the location where the written data ends.\n   */\n  async write(data, location) {\n    this.ensureLocked({invalidMode: \"readonly\"});\n    if (typeof location === \"number\") {\n      this.lockedFile.location = location;\n    }\n    return waitForDOMRequest(\n      this.lockedFile.write(data),\n      // Resolves to the new location.\n      () => {\n        return this.lockedFile.location;\n      }\n    );\n  }\n\n  /**\n   * Queue data to be written into the file (optionally starting from a defined location in the file).\n   *\n   * @param {string|ArrayBuffer} data\n   *   The data to write into the file.\n   * @param {number} location\n   *   The location where the data should be written (when not specified the end of the previous\n   *   queued write is used).\n   *\n   * @returns {Promise<number>}\n   *   A promise which is resolved once the request has been completed with the location where the\n   *   file was after the data has been writted.\n   */\n  queuedWrite(data, location) {\n    const nextWriteRequest = async lastLocation => {\n      this.ensureLocked({invalidMode: \"readonly\"});\n\n      if (typeof location === \"number\") {\n        return this.write(data, location);\n      }\n      return this.write(data, lastLocation);\n    };\n\n    this.writeQueue = this.writeQueue.then(nextWriteRequest);\n    return this.writeQueue;\n  }\n\n  /**\n   * Wait that any queued data has been written.\n   *\n   * @returns {Promise<number>}\n   *   A promise which is resolved once the request has been completed with the location where the\n   *   file was after the data has been writted.\n   */\n  async waitForQueuedWrites() {\n    await this.writeQueue;\n  }\n}\n\n/**\n * Wraps an IDBMutableFile with a nicer Promise-based API.\n *\n * Instances of this class are created from the\n * {@link IDBFileStorage.createMutableFile} method.\n */\nexport class IDBPromisedMutableFile {\n  /**\n   * @private private helper method used internally.\n   */\n  constructor({filesStorage, idb, fileName, fileType, mutableFile}) {\n    // All the following properties are private and it should not be needed\n    // while using the API.\n\n    /** @private */\n    this.filesStorage = filesStorage;\n    /** @private */\n    this.idb = idb;\n    /** @private */\n    this.fileName = fileName;\n    /** @private */\n    this.fileType = fileType;\n    /** @private */\n    this.mutableFile = mutableFile;\n  }\n\n  /**\n   * @private private helper method used internally.\n   */\n  reopenFileHandle(fileHandle) {\n    fileHandle.lockedFile = this.mutableFile.open(fileHandle.mode);\n  }\n\n  // API methods.\n\n  /**\n   * Open a mutable file for reading/writing data.\n   *\n   * @param {\"readonly\"|\"readwrite\"|\"writeonly\"} mode\n   *   The mode of the created IDBPromisedFileHandle instance.\n   *\n   * @returns {IDBPromisedFileHandle}\n   *   The created IDBPromisedFileHandle instance.\n   */\n  open(mode) {\n    if (this.lockedFile) {\n      throw new Error(\"MutableFile cannot be opened twice\");\n    }\n    const lockedFile = this.mutableFile.open(mode);\n\n    return new IDBPromisedFileHandle({file: this, lockedFile});\n  }\n\n  /**\n   * Get a {@link File} instance of this mutable file.\n   *\n   * @returns {Promise<File>}\n   *   A promise resolved to the File instance.\n   *\n   * To read the actual content of the mutable file as a File object,\n   * it is often better to use {@link IDBPromisedMutableFile.saveAsFileSnapshot}\n   * to save a persistent snapshot of the file in the IndexedDB store,\n   * or reading it directly using the {@link IDBPromisedFileHandle} instance\n   * returned by the {@link IDBPromisedMutableFile.open} method.\n   *\n   * The reason is that to be able to read the content of the returned file\n   * a lockfile have be keep the file open, e.d. as in the following example.\n   *\n   * @example\n   *     ...\n   *     let waitSnapshotStored;\n   *     await mutableFile.runFileRequestGenerator(function* (lockedFile) {\n   *       const file = yield lockedFile.mutableFile.getFile();\n   *       // read the file content or turn it into a persistent object of its own\n   *       // (e.g. by saving it back into IndexedDB as its snapshot in form of a File object,\n   *       // or converted into a data url, a string or an array buffer)\n   *\n   *       waitSnapshotStored = tmpFiles.put(\"${filename}/last_snapshot\", file);\n   *     }\n   *\n   *     await waitSnapshotStored;\n   *     let fileSnapshot = await tmpFiles.get(\"${filename}/last_snapshot\");\n   *     ...\n   *     // now you can use fileSnapshot even if the mutableFile lock is not active anymore.\n   */\n  getFile() {\n    return waitForDOMRequest(this.mutableFile.getFile());\n  }\n\n  /**\n   * Persist the content of the mutable file into the files storage\n   * as a File, using the specified snapshot name and return the persisted File instance.\n   *\n   * @returns {Promise<File>}\n   *   A promise resolved to the File instance.\n   *\n   * @example\n   *\n   *      const file = await mutableFile.persistAsFileSnapshot(`${filename}/last_snapshot`);\n   *      const blobURL = URL.createObjectURL(file);\n   *      ...\n   *      // The blob URL is still valid even if the mutableFile is not active anymore.\n   */\n  async persistAsFileSnapshot(snapshotName) {\n    if (snapshotName === this.fileName) {\n      throw new Error(\"Snapshot name and the file name should be different\");\n    }\n\n    const idb = await this.filesStorage.initializedDB();\n    await this.runFileRequestGenerator(function* () {\n      const file = yield this.mutableFile.getFile();\n      const objectStore = this.filesStorage.getObjectStoreTransaction({idb, mode: \"readwrite\"});\n\n      yield objectStore.put(file, snapshotName);\n    }.bind(this));\n\n    return this.filesStorage.get(snapshotName);\n  }\n\n  /**\n   * Persist the this mutable file into its related IDBFileStorage.\n   *\n   * @returns {Promise}\n   *   A promise resolved on the mutable file has been persisted into IndexedDB.\n   */\n  persist() {\n    return this.filesStorage.put(this.fileName, this);\n  }\n\n  /**\n   * Run a generator function which can run a sequence of FileRequests\n   * without the lockfile to become inactive.\n   *\n   * This method should be rarely needed, mostly to optimize a sequence of\n   * file operations without the file to be closed and automatically re-opened\n   * between two file requests.\n   *\n   * @param {function* (lockedFile) {...}} generatorFunction\n   * @param {\"readonly\"|\"readwrite\"|\"writeonly\"} mode\n   *\n   * @example\n   *   (async function () {\n   *      const tmpFiles = await IDBFiles.getFileStorage({name: \"tmpFiles\"});\n   *      const mutableFile = await tmpFiles.createMutableFile(\"test-mutable-file.txt\");\n   *\n   *      let allFileData;\n   *\n   *      function* fileOperations(lockedFile) {\n   *        yield lockedFile.write(\"some data\");\n   *        yield lockedFile.write(\"more data\");\n   *        const metadata = yield lockedFile.getMetadata();\n   *\n   *        lockedFile.location = 0;\n   *        allFileData = yield lockedFile.readAsText(metadata.size);\n   *      }\n   *\n   *      await mutableFile.runFileRequestGenerator(fileOperations, \"readwrite\");\n   *\n   *      console.log(\"File Data\", allFileData);\n   *   })();\n   */\n  async runFileRequestGenerator(generatorFunction, mode) {\n    if (generatorFunction.constructor.name !== \"GeneratorFunction\") {\n      throw new Error(\"runGenerator parameter should be a generator function\");\n    }\n\n    await new Promise((resolve, reject) => {\n      const lockedFile = this.mutableFile.open(mode || \"readwrite\");\n      const fileRequestsIter = generatorFunction(lockedFile);\n\n      const processFileRequestIter = prevRequestResult => {\n        const nextFileRequest = fileRequestsIter.next(prevRequestResult);\n        if (nextFileRequest.done) {\n          resolve();\n          return;\n        } else if (!(nextFileRequest.value instanceof window.DOMRequest ||\n                     nextFileRequest.value instanceof window.IDBRequest)) {\n          const error = new Error(\"FileRequestGenerator should only yield DOMRequest instances\");\n          fileRequestsIter.throw(error);\n          reject(error);\n          return;\n        }\n\n        const request = nextFileRequest.value;\n        if (request.onsuccess || request.onerror) {\n          const error = new Error(\"DOMRequest onsuccess/onerror callbacks are already set\");\n          fileRequestsIter.throw(error);\n          reject(error);\n        } else {\n          request.onsuccess = () => processFileRequestIter(request.result);\n          request.onerror = () => reject(request.error);\n        }\n      };\n\n      processFileRequestIter();\n    });\n  }\n}\n\n/**\n * Provides a Promise-based API to store files into an IndexedDB.\n *\n * Instances of this class are created using the exported\n * {@link getFileStorage} function.\n */\nexport class IDBFileStorage {\n  /**\n   * @private private helper method used internally.\n   */\n  constructor({name, persistent} = {}) {\n    // All the following properties are private and it should not be needed\n    // while using the API.\n\n    /** @private */\n    this.name = name;\n    /** @private */\n    this.persistent = persistent;\n    /** @private */\n    this.indexedDBName = `IDBFilesStorage-DB-${this.name}`;\n    /** @private */\n    this.objectStorageName = \"IDBFilesObjectStorage\";\n    /** @private */\n    this.initializedPromise = undefined;\n\n    // TODO: evalutate schema migration between library versions?\n    /** @private */\n    this.version = 1.0;\n  }\n\n  /**\n   * @private private helper method used internally.\n   */\n  initializedDB() {\n    if (this.initializedPromise) {\n      return this.initializedPromise;\n    }\n\n    this.initializedPromise = (async () => {\n      if (window.IDBMutableFile && this.persistent) {\n        this.version = {version: this.version, storage: \"persistent\"};\n      }\n      const dbReq = indexedDB.open(this.indexedDBName, this.version);\n\n      dbReq.onupgradeneeded = () => {\n        const db = dbReq.result;\n        if (!db.objectStoreNames.contains(this.objectStorageName)) {\n          db.createObjectStore(this.objectStorageName);\n        }\n      };\n\n      return waitForDOMRequest(dbReq);\n    })();\n\n    return this.initializedPromise;\n  }\n\n  /**\n   * @private private helper method used internally.\n   */\n  getObjectStoreTransaction({idb, mode} = {}) {\n    const transaction = idb.transaction([this.objectStorageName], mode);\n    return transaction.objectStore(this.objectStorageName);\n  }\n\n  /**\n   * Create a new IDBPromisedMutableFile instance (where the IDBMutableFile is supported)\n   *\n   * @param {string} fileName\n   *   The fileName associated to the new IDBPromisedMutableFile instance.\n   * @param {string} [fileType=\"text\"]\n   *   The mime type associated to the file.\n   *\n   * @returns {IDBPromisedMutableFile}\n   *   The newly created {@link IDBPromisedMutableFile} instance.\n   */\n  async createMutableFile(fileName, fileType = \"text\") {\n    if (!window.IDBMutableFile) {\n      throw new Error(\"This environment does not support IDBMutableFile\");\n    }\n    const idb = await this.initializedDB();\n    const mutableFile = await waitForDOMRequest(\n      idb.createMutableFile(fileName, fileType)\n    );\n    return new IDBPromisedMutableFile({\n      filesStorage: this, idb, fileName, fileType, mutableFile\n    });\n  }\n\n  /**\n   * Put a file object into the IDBFileStorage, it overwrites an existent file saved with the\n   * fileName if any.\n   *\n   * @param {string} fileName\n   *   The key associated to the file in the IDBFileStorage.\n   * @param {Blob|File|IDBPromisedMutableFile|IDBMutableFile} file\n   *   The file to be persisted.\n   *\n   * @returns {Promise}\n   *   A promise resolved when the request has been completed.\n   */\n  async put(fileName, file) {\n    if (!fileName || typeof fileName !== \"string\") {\n      throw new Error(\"fileName parameter is mandatory\");\n    }\n\n    if (!(file instanceof File) && !(file instanceof Blob) &&\n        !(window.IDBMutableFile && file instanceof window.IDBMutableFile) &&\n        !(file instanceof IDBPromisedMutableFile)) {\n      throw new Error(`Unable to persist ${fileName}. Unknown file type.`);\n    }\n\n    if (file instanceof IDBPromisedMutableFile) {\n      file = file.mutableFile;\n    }\n\n    const idb = await this.initializedDB();\n    const objectStore = this.getObjectStoreTransaction({idb, mode: \"readwrite\"});\n    return waitForDOMRequest(objectStore.put(file, fileName));\n  }\n\n  /**\n   * Remove a file object from the IDBFileStorage.\n   *\n   * @param {string} fileName\n   *   The fileName (the associated IndexedDB key) to remove from the IDBFileStorage.\n   *\n   * @returns {Promise}\n   *   A promise resolved when the request has been completed.\n   */\n  async remove(fileName) {\n    if (!fileName) {\n      throw new Error(\"fileName parameter is mandatory\");\n    }\n\n    const idb = await this.initializedDB();\n    const objectStore = this.getObjectStoreTransaction({idb, mode: \"readwrite\"});\n    return waitForDOMRequest(objectStore.delete(fileName));\n  }\n\n  /**\n   * List the names of the files stored in the IDBFileStorage.\n   *\n   * (If any filtering options has been specified, only the file names that match\n   * all the filters are included in the result).\n   *\n   * @param {IDBFileStorage.ListFilteringOptions} options\n   *   The optional filters to apply while listing the stored file names.\n   *\n   * @returns {Promise<string[]>}\n   *   A promise resolved to the array of the filenames that has been found.\n   */\n  async list(options) {\n    const idb = await this.initializedDB();\n    const objectStore = this.getObjectStoreTransaction({idb});\n    const allKeys = await waitForDOMRequest(objectStore.getAllKeys());\n\n    let filteredKeys = allKeys;\n\n    if (options) {\n      filteredKeys = filteredKeys.filter(key => {\n        let match = true;\n\n        if (typeof options.startsWith === \"string\") {\n          match = match && key.startsWith(options.startsWith);\n        }\n\n        if (typeof options.endsWith === \"string\") {\n          match = match && key.endsWith(options.endsWith);\n        }\n\n        if (typeof options.includes === \"string\") {\n          match = match && key.includes(options.includes);\n        }\n\n        if (typeof options.filterFn === \"function\") {\n          match = match && options.filterFn(key);\n        }\n\n        return match;\n      });\n    }\n\n    return filteredKeys;\n  }\n\n  /**\n   * Count the number of files stored in the IDBFileStorage.\n   *\n   * (If any filtering options has been specified, only the file names that match\n   * all the filters are included in the final count).\n   *\n   * @param {IDBFileStorage.ListFilteringOptions} options\n   *   The optional filters to apply while listing the stored file names.\n   *\n   * @returns {Promise<number>}\n   *   A promise resolved to the number of files that has been found.\n   */\n  async count(options) {\n    if (!options) {\n      const idb = await this.initializedDB();\n      const objectStore = this.getObjectStoreTransaction({idb});\n      return waitForDOMRequest(objectStore.count());\n    }\n\n    const filteredKeys = await this.list(options);\n    return filteredKeys.length;\n  }\n\n  /**\n   * Retrieve a file stored in the IDBFileStorage by key.\n   *\n   * @param {string} fileName\n   *   The key to use to retrieve the file from the IDBFileStorage.\n   *\n   * @returns {Promise<Blob|File|IDBPromisedMutableFile>}\n   *   A promise resolved once the file stored in the IDBFileStorage has been retrieved.\n   */\n  async get(fileName) {\n    const idb = await this.initializedDB();\n    const objectStore = this.getObjectStoreTransaction({idb});\n    return waitForDOMRequest(objectStore.get(fileName)).then(result => {\n      if (window.IDBMutableFile && result instanceof window.IDBMutableFile) {\n        return new IDBPromisedMutableFile({\n          filesStorage: this,\n          idb,\n          fileName,\n          fileType: result.type,\n          mutableFile: result\n        });\n      }\n\n      return result;\n    });\n  }\n\n  /**\n   * Remove all the file objects stored in the IDBFileStorage.\n   *\n   * @returns {Promise}\n   *   A promise resolved once the IDBFileStorage has been cleared.\n   */\n  async clear() {\n    const idb = await this.initializedDB();\n    const objectStore = this.getObjectStoreTransaction({idb, mode: \"readwrite\"});\n    return waitForDOMRequest(objectStore.clear());\n  }\n}\n\n/**\n * Retrieve an IDBFileStorage instance by name (and it creates the indexedDB if it doesn't\n * exist yet).\n *\n * @param {Object} [param]\n * @param {string} [param.name=\"default\"]\n *   The name associated to the IDB File Storage.\n * @param {boolean} [param.persistent]\n *   Optionally enable persistent storage mode (not enabled by default).\n *\n * @returns {IDBFileStorage}\n *   The IDBFileStorage instance with the given name.\n */\nexport async function getFileStorage({name, persistent} = {}) {\n  const filesStorage = new IDBFileStorage({name: name || \"default\", persistent});\n  await filesStorage.initializedDB();\n  return filesStorage;\n}\n\n/**\n * @external {Blob} https://developer.mozilla.org/en-US/docs/Web/API/Blob\n */\n\n/**\n * @external {DOMRequest} https://developer.mozilla.org/en/docs/Web/API/DOMRequest\n */\n\n/**\n * @external {File} https://developer.mozilla.org/en-US/docs/Web/API/File\n */\n\n/**\n * @external {IDBMutableFile} https://developer.mozilla.org/en-US/docs/Web/API/IDBMutableFile\n */\n\n/**\n * @external {IDBRequest} https://developer.mozilla.org/en-US/docs/Web/API/IDBRequest\n */\n"]}